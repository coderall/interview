--- 内核相关面试题目汇总 ---

// CPU 调度&进程管理

1、简单介绍下 O(1)调度算法

2、简单介绍下CFS算法，和O(1)算法的不同之处在哪

3、什么是IDT，有什么用

4、中断处理 和 内核态调用 哪个优先级高，为什么？

5、IPI是什么，有什么用？

6、pthread_mutex 默认情况下 对同一个锁 重复加锁两次 会有什么效果，为什么？

7、pthread_mutex 怎么实现？ 使用了哪个系统调用？

8、可以在线程中调用fork吗？为什么？

9、内核是怎么处理僵尸进程的？
	(tips：由init进程来回收僵尸进程)

10、ps的命令中，怎么知道哪个是内核线程(一般情况下)，内核线程又是怎么实现的？
	(tips：使用 ps -afx 可以查看所有的内核线程)

11、在内核中，怎么获取当前进程的 task_struct 结构？

12、为什么在spinlock的临界区中不能睡眠？
	(tips：1 在临界区睡眠不符合spinlock加锁临界区快速执行的语义
	2 有可能导致死锁)

13、为什么在中断处理程序中不能睡眠？

14、内核中使用较多的锁都有哪些？作用都有哪些？

15、简单解释下RCU？
	(tips：和读写锁相同，多个读者之间可以并行访问，但有读者时，写者不用阻塞等待，可以新申请空间，
	更新后再将原指针替换，具体做法依赖于优雅周期的判断，多个写者之间的同步？ TODO)

16、解释下uptime命令的输出？具体的计算依据是什么？（CPU run queue中 runnable进程和处于D状态的进程数量）
	(tips：计算方式类似于统计时间段内平均值)

17、nice命令的作用有哪些？

18、进程的静态优先级和动态优先级的概念？

19、top 命令输出中 hi 列 si 列 分别代表什么？

20、mpstat 或者 sar 命令中 steal% 列代表什么意思？

21、解释下bogomips？

22、内核中表示时钟中断频率的常量值是哪个？在命令行中怎么查看？

23、后台服务器和桌面系统的时钟中断频率值有什么差别？为什么要这样设置？

24、chrt 作用有哪些？

25、简单解释下 CFS 调度算法中的vruntime概念？

26、fork 调用后 父进程先执行还是子进程先执行？

27、解释下 sched_yield 函数？

28、怎样查看系统是否支持cgroup？

29、怎样避免程序被调试执行（安全相关）？
    tips：PTRACE_TRACEME & SIGTRAP handler & /proc/self/status
 
30、简单解释下 vsyscall & vdso ？

31、/proc/kcore文件有什么用？

32、/proc/kallsyms文件有什么用？

33、linux的线程实现方式？

34、简单描述下线程组中接收到信号的处理？

35、task_struct结构中pid，tgid的作用？

36、getpid(),gettid()实现？
   (tips:getpid其实取的值是tgid，gettid取的值是pid，有点绕。其实还是和LWP的实现方式相关)
   
37、pthread_self() 又是怎么实现的呢？和上面两个函数的区别和联系分别是什么？

38、top命令显示中S列代表什么？"I"表示什么状态？

39、什么是内核抢占？在多核系统中怎么定义？

40、preempt_enable是一个抢占点吗？为什么？
	（tips：在preemt_enable函数中，会尝试抢占执行，具体参考源码实现）

41、sysenter和sysexit指令实现了什么功能？

42、SCHED_FIFO SCHED_RR SCHED_NORMAL 三种调度策略有什么区别？

43、什么是DMA？

44、什么是RDMA？

45、什么是IPI？有什么作用？

46、CFS中通过什么方法来避免fork出的新进程总是优先于其他进程执行？

47、CFS算法中怎样保证长时间睡眠的进程被唤醒时（vruntime很小），不至于长时间占用CPU？

48、CFS算法中，进程从一个CPU上迁移到另一个CPU，对应的vruntime会不会变？为什么要这样做？

49、系统中最大进程数由什么控制？
    （tips：之前的设计中，进程数量还受到GDT表项的限制，但现在没有这个问题了）

50、pread和pwrite在哪种场合下使用较多？
    （tips：因为pread和pwrite的操作不修改对应fd的offset，所以在多线程读写方面有优势）

51、access_ok 宏有什么作用？

52、链接静态库时，单个.o文件中未引用的部分的优化方式是什么？

53、什么是LLC cache？

54、Intel 的 Skylake 和 Broadwell架构有什么区别，带来了什么影响？

55、spinlock怎么实现？（考虑多核情况）
	(tips：当前内核中采用ticket-based算法来实现；
	之前的实现是采用一个简单变量的0和1取值来判断是否加锁，这有一个问题就是在多核场景下，
	之前加锁的CPU因为L1 cache中有缓存锁数据，导致其他CPU忙等，现在的解决方案类似吃饭排队拿好号牌，
	当排队等待的CPU的号牌等于下一个可加锁的号码时，加锁成功)
	
56、Linux现在的实现中中断允许嵌套吗？为什么？

57、当内核现在正处于中断处理上半部时，后面来的中断怎么处理？丢掉还是？
	（tips：pengding）

58、怎样禁止 ping 请求？
	（tips： echo 1 > /proc/sys/net/ipv4/icmp_echo_ignore_all）
	
59、系统重启后上述的禁止 ping 会失效，怎么解决？
	(tips： 在 /etc/sysctl.conf文件中添加 net.ipv4.conf.icmp_echo_ignore_all=1)
	
60、nice值在 O(1) 和 CFS 算法中有什么不同的含义？

61、oops 和 panic 一样吗？
	(tips：不一样，在硬中断或软中断中，如果oops，那么肯定panic，即内核崩溃，如果是在进程上下文中，那么发送SIGSEGV信号，如果配置了oops_on_panic选项为1，那么在oops中内核也会崩溃。总结就是 oops 不一定会引起 内核 panic)
	
62、write被中断打断后，会返回什么？ERRNO又会是什么？
	(tips：尤其是在处理网络请求时要注意)
	
63、上下文切换有哪几种？都有哪些寄存器参与了上下文切换？
	(tips:具体有进程上下文切换，中断上下文切换，线程的上下文切换
	进程的上下文切换中，TLB尤其重要；中断上下文中涉及到了很多和
	中断标志等有关的信息的保存；线程上下文切换则相对比较轻量)
	
64、怎样查看进程具体的上下文切换数据？
	(tips：pidstat -w 参数可以查看上下文切换是自愿还是被动
	更加具体的中断信息，需要查看/proc/interrupts文件中数据)
	
65、top 或 pidstat中展示的CPU使用率信息怎么计算？
	(tips：通过/proc/cpu 信息计算或者 /proc/{pid}/stat
	计算方式其实是1-TimeIdle/TimeTotal)
	
66、 内核线程和用户线程有什么区别？
	(tips：1 创建方式不同，用户态线程通过clone或fork创建
	2 内核线程没有自己的栈空间，使用内核栈，且使用上一个进程的内存空间
	3 内核线程一直运行于内核态)
	
67、怎样做到进程不重启 而升级库文件版本？
	(tips：使用dlopen得到所有使用的接口函数指针，然后替换文件（这一步是安全的，因为对应库文件已经映射到内存中，
	磁盘文件的修改不会影响程序运行），然后向进程发送信号等方式来通知，
	进程等到所有引用这个接口的处理完成后，再重新dlopen保存新的函数指针)
	
68、PID的选择策略是什么？
	(tips：从上一次使用的PID往后查找到PID_MAX，如果没找到，再从头开始查找，
	但是并不是从0开始，而是从300，因为0~300预留给了系统进程使用)
	
69、PID_MAX的取值是多少？
	(tips：32位系统和64位系统的取值不一样，32位系统大概在32768,64位系统在4MB)
	
70、fork调用后，父进程在调用前打开的文件，子进程可以看到吗？
	(tips：可以，fork实现中的do_fork拷贝了文件描述符，但是两个打开文件表指向的是相同的file结构，
	那么文件偏移量也是共享的，但是之后子进程打开的文件，两者不共享)
	
71、什么是僵尸进程？
	(tips：在进程结束后，task struct 结构不是直接回收的，而是要以SIGCHLD信号通知父进程，
	父进程调用wait方法获取到退出状态后，子进程才算完整的结束，对应结构也会被回收。
	如果不想被回收，那么通常的做法是调用两次fork，第二次fork的父进程在子进程之前退出，
	显示的告诉内核不由父进程负责回收)
	
72、wait waitpid的实现？
	(tips：等待子进程退出，并获取退出状态，子进程的退出值在 exit 字段中表示)
	
73、exit函数的参数取值有什么约定？

74、如果线程组里面，非主线程的线程退出，需要通知父进程吗？
	(tips：不需要，task_struct结构直接回收)
	
75、接上面的题目，如果主线程先于其他线程退出，那么由谁来给父进程发信号？
	(tips：由最后一个退出的线程来完成这个工作)
	
76、父进程怎样获知 子进程的执行结束？
	(tips：一种是由 子进程通过信号来通知；另一种是 父进程通过wait后，将自己挂入等待队列，
	子进程退出时，再唤醒父进程等待队列里面的进程)
	
77、为什么spinlock临界区不允许发生抢占？
	(tips：因为有可能导致死锁)
	
78、系统中的mutex实现了自旋等待，即加锁失败时，并不是立即加入等待队列，而是尝试自旋等待持有锁的调用者释放锁

79、系统中的mutex和futex有什么区别？
	(tips：1 mutex的锁在内核中，futex的锁在用户态中
	2 mutex的锁内核只是做了加锁或睡眠等待，futex明确告诉内核调用者的一个期望
	3 两者都有实现唤醒和睡眠)

80、进程收到SIGKILL后，会有dump文件吗？
    (tips：SIGKILL信号系统的默认行为为终止对应进程，没有dump文件产生，
     但是，当收到SIGTERM信号时，有dump文件产生)

81、OOM时的进程选择机制是什么？
    (tips：根据/proc/${pid}/oom_score来选择一个值最大的进程，一般来说，
     内存占用量高的进程这个值较大，但是如果是 root 用户的进程，会减去30分，
     因为内核认为root用户的进程重要性更高，如果有CAP_SYS_ADMIN权限，
     则会减去 score的 3%)

82、barrier的作用是什么？
    (tips：乱序访问分为 编译时乱序和执行时乱序，编译时乱序通常由高级别的优化引入，例如 -O2，
     编译乱序可以通过内嵌汇编的方式解决；
     执行时乱序则需要通过CPU相关的fence指令来避免；
     单CPU执行时，不存在执行时乱序，但是有可能有编译时乱序，
     这里可以参考内核里面相关mb()函数的定义)

83、/proc/${pid}/oom_adj 作用是什么？
    (tips：计算oom_score的一个参考数值)

84、/proc/${pid}/oom_score_adj 作用是什么，和上面的变量的区别是？
    (tips：oom_score_adj是一个新的参数数值，oom_adj的取值范围为 -17~+15,
     oom_score_adj的取值范围为 -1000~+1000，且系统建议使用新的oom_score_adj)

85、OOM时发送的信号是什么？
    (tips：发送SIGKILL信号)

86、添加cgroup规则后，超过内存使用限制会OOM吗？
    (tips：cgroup中OOM是默认开启的)

86、SIGKILL 和 SIGSTOP 两个信号不能被忽略，也不能由应用使用自定义信号处理函数捕获

// 内存管理

1、malloc的实现

2、简单介绍下 tcmalloc 或 jemalloc 或 ptmalloc

3、简单介绍下 buddy system

4、简单介绍下 slab

5、内核初始化时使用的内存分配算法是什么？

6、内核的一级页表和二级页表分别存放在哪里？

7、slab是怎样避免内存碎片的？

8、slab分配的是物理内存还是虚拟内存？

9、buddy system 分配的是物理内存还是虚拟内存？

10、简单解释下slab着色？

11、匿名页面和文件缓冲页面有什么区别？

12、解释下什么是 NUMA？

13、使用哪个命令来查看NUMA信息？

14、/proc/interrupts 文件内容解释？

15、应用程序中怎样将虚拟地址转换为物理地址？

16、简单描述下 /proc/{pid}/pagemap？ -> Q:15

17、为什么malloc的实现中，大于128K的内存使用mmap？

18、什么是内存巨页？相比于传统的页大小有什么优势？

19、简单描述下hugetblfs？

20、怎样查看系统是否开启了巨页？

21、什么是PAE，有什么作用？怎么实现？
	(tips：PAE表示物理地址扩展，解决了32位虚拟地址在大于4G环境下，仍然只能映射4G物理地址的问题
	具体细节是，32位地址的高两位用来选择页目录表表项，接下来的9位表示页目录项，
	再接下来的9位表示页表项，剩下的12位仍然表示页内偏移；页表项扩展为64位，从12到35位表示物理地址前缀
	这样 24 + 12 = 36，可以表示64GB物理地址空间)

22、CPU的 CR3 寄存器存放的是什么？

23、Linux的页表访问分为几个层级？具体实现方式？

24、什么是swap，有什么作用？

25、什么是内存overcommit？
    (tips：操作系统向外提供的内存总量比 RAM+Swap 多，这里有一个假设就是，
     应用申请的一些内存并没有使用，或使用了很快释放，当触发缺页中断时，
     还是要申请物理内存，并且要考虑OOM机制的影响)

26、系统可配置的处理overcommit策略都有哪些？
    (tips：vm.overcommit_memory和vm.overcommit_ratio proc变量的取值)

27、怎样判断进程有overcommit行为？

28、系统内存空间紧张后的回收策略都有哪些？

29、kswapd 线程有什么作用？

30、什么是同步回收，什么是异步回收？

31、什么情况下会启动kswapd线程？

32、kswapd是否是多线程的？
	(tips：大多数系统上为单线程，但已经有人提出了多线程版本的patch)
	
33、kswapd 消耗CPU过高的问题怎么解决？

34、vm.swapiness 系统参数的作用是？

35、swapoff 和 swapon 命名有什么作用？

36、/proc/sys/vm/drop_caches 传入 1 2 3 分别代表什么？
	(tips：1 表示只回收pageCache，2表示回收dentries和inode，3表示上述两个都回收)

37、缓存一致性协议有哪几种实现方式？
	(tips：基于目录的MESI实现和基于总线通讯的实现)
	
38、Power系列CPU 和 x86CPU 的比较？

39、split lock是什么？
	(tips：MESI协议只能保证Cache line的数据一致性，而如果数据跨越了Cache line，则仍然需要锁总线，这就是split lock，
	不利于性能提升)
	
40、什么是 Power Virsus？
	(tips：指一类高功耗程序，CPU热量增加，触发THP，CPU会强制降频，这在多租户的情况下，会影响其他VM)
	
41、Intel RDT 技术，实现了高速缓存、内存带宽级别的资源隔离，具体包括，CMT(高速缓存监控)，CAT（高速缓存分配），
	MBM（内存带宽监控），代码和数据优先级（CDP）
	
42、touch 命令的作用？
	(tips：touch命令更新文件的access time 和 modify time，这在make编译程序时常用，在不修改文件内容的情况下，
	触发重编译)
	
43、编译器如何处理inline函数中的static变量？
	(tips：这里的处理和inline函数本身没什么关系；带有extern属性的函数，编译器保证多次调用函数时，static变量指向的是同一个对象，
	如果是internal类型的inline函数，就更能保证这一点。static函数中的static变量在不同的编译单元中都有一份定义)
	
44、flock对于dup操作的特点是？
	(tips：dup操作后，因为使用的是同一个打开文件，所以仍然共有flock属性)，如果一个文件被打开多次，
	那么就是不同的文件描述符，所以锁是独立的。一个文件flock后，后续的其他打开文件不进行flock操作也可以进行正常的读写，
	所以说flock是一种逻辑锁。
	
45、dmesg命令的作用是？
	(tips：dmesg查看内核中的环形缓冲区信息，可以获得如CPU、硬盘、网卡等设备的信息)
	
46、什么是 cc-NUMA ？
	(tips：即保证数据一致性的NUMA架构，主要的是Cache的数据一致性)
	
47、NMI中断表示什么意思？
	(tips：NMI表示Non-Mask Interrupt，即不可屏蔽中断，不可以通过CLI设置标志寄存器的IF位而忽略)
	
48、CPU本身是否支持中断优先级？
	(tips：CPU本身是有支持中断优先级的，但是位于同一个优先级内的多个中断的处理可能与CPU型号有关)
	
49、为什么两次mmap同样的地址，没有报错？
	(tips：因为第二次mmap时，会先unmap之前的映射，然后再次尝试mmap)
	
50、DR0 ~ DR7寄存器的作用？
	(tips：硬件断点的实现)
	
51、IVT 和 IDT有什么区别？
	(tips：IVT是中断向量表用来在实模式下处理中断，IDT是中断描述符表，用来在保护模式下处理中断)
	
52、malloc刚申请的内存内容显示“烫”表示什么？
	(tips：调试模式下保护程序访问未初始化的内容内容，其实质是 int 3指令，用来触发调试)
	
53、写时复制(COW)是通过什么实现的？
	(tips：通过缺页中断来实现)
	
54、缺页中断会发生在内核态吗？为什么？

55、内核中struct page 并没有指向具体内存的指针，那么page对应的存储空间怎么表示？

56、struct page结构中的 _count 和 _mapcount 有什么区别？
	(tips：_count表示内核中引用当前页面的数量，_mapcount表示有多少个进程映射了当前页面)
	
57、反向映射的技术实现是？
	(tips：早期通过遍历进程来实现，效率较低，之后的实现方法是父进程中有一个链表用来保存共享页面，
	如果需要从page找到对应的进程，则遍历这个链表，更新的实现是通过一个中间结构来衔接父进程和子进程，
	映射的共享页面加入到红黑树中加快查找过程。)
	
58、怎么判断一个page是匿名映射还是文件映射？
	(tips：page结构中的mapping字段的低两位有对应的掩码来标识当前页面的匿名页面还是文件映射页面)
	
59、反向映射的典型应用场景有哪些？
	(tips：kswapd内核线程回收页面时，页面迁移时，需要重新映射对应的PTE表项)
	
60、什么是KSM页面？
	(tips：KSM页面是指Kernel Shareable Merge页面，由madvise函数创建，且使用MERGEABLE标志)
	
61、KSM页面的使用场景是？
	(tips：有研究指出，在多虚拟机环境下，虚拟机主要使用的是匿名页面，且各个页面映射的物理页面的内容一样，
	这就可以合并页面，释放多余的物理页面)
	
62、KSM具体实现细节是？
	(tips：首先通过madvise创建的页面加入到对应的KSM 链表，然后扫描stable树，找到候选的页面，
	通过校验和机制来确定物理页面是一样的，然后修改PTE指向，这里需要注意，当修改多个PTE指向相同物理页面后，
	该页面需要执行COW，即当有人修改时，还是需要分离页面)
	
63、如果用户空间使用 PROT_READ 来mmap映射一个文件到用户空间，然后使用memcpy来写这段内存空间，会发生什么？
	(tips：内核会检测到权限不匹配，产生对应的段错误)
	
64、假设在内核空间获取了某个文件对应的page cache页面的struct page数据结构，对应的VMA是只读的，
	那么内核空间是否可以修改该page的内容呢？
	(tips：可以，内核空间和用户空间使用的PTE不一样，内核利用KMAP机制映射页面是可写的)
	
65、如何由mm数据结构和虚拟地址vaddr 找到对应的VMA？
	(tips：vma记录在以起始地址为key的一个红黑树中，所以只需要查找这个红黑树就可以找到)
	
66、如何由page和VMA找到虚拟地址vaddr？
	(tips：page->index记录了vma中的偏移量，加上vma->start_addr)
	
67、如何由page找到所有映射的VMA？
	(tips：反向映射的实现)
	
68、如何由VMA和vaddr找出相应的page数据结构
	(tips：根据vaddr 在页表中查找到pfn，然后在全局page数组中根据下标访问)
	
69、什么是OOM？
	(tips：内存紧张时，向进程发送SIGKILL信号)
	
70、flock的实现？
	(tips：flock是基于struct file结构中的flags实现的，本身并不基于inode中的锁，但是，
	考虑到同一个文件可能在不同进程中open，包括同一进程open多次，具体实现中是在inode中以链表的形式来
	保存锁信息)
	
71、flock锁定的文件，是否可以unlink？
	(tips：可以，不影响)
	
72、内核在面对多核系统时，都可能有哪些瓶颈点？
	(tips：CPU级别的负载均衡，per-cpu runqueue，合理使用IPI机制，内存分配中的锁的合理使用，NUMA环境下的内存分配，
	I/O队列的per-cpu设计，网络收发队列的per-cpu设计，各个统计计数功能的per-cpu设计)
	
73、在64位系统中为什么不存在高端内存的概念？
	(tips：因为在64位系统中，内核可以使用的内存有128T，而机器上真正安装的内存大小小于这个数值，
	所以用不到高端内存)
	
74、x86 和 x86_64 系统中 zone 的表示有什么不同？
	(tips：x86_64系统中不存在 ZONE_HIGHMEM，如果外设可以访问高于16M且小于4G空间时，增加ZONE_DMA32)
	
75、用户空间进程是否有高端内存概念？
	(tips：没有)
	
76、为什么不把所有地址空间分配给内核使用？
	(tips：因为没有这个必要，不是所有的程序都需要运行在内核态，即用户态访问用户态数据，内核态访问内核数据)
	
77、rename 函数时原子的吗？
	(tips：查看man page 这个函数是原子的执行的)
	
78、内核栈空间一般多大？
	(tips：8KB，两个页面大小)
	
79、getpid 和 gettid 分别返回什么？
	(tips：POSIX规定，同一个线程组内的线程共享一个PID，但是Linux内核为每一个线程都分配了不同的PID，为了满足协议要求，
	就添加了thread group id的概念，这样，getpid 返回的其实就是 thread group id，而gettid返回的是线程真正的PID)
	
80、面试题，for循环，然后调用 fork，回答打印的字符数量？
	(tips：如果打印在前，fork在后，那么数量就是以循环次数为高的树的叶子节点总数
	如果fork在前，print在后，那么打印的数量就是以循环次数+1为高的树的叶子结点总数-1(减去根节点))
	
81、CFS调度器中，怎样计算vruntime？
	(tips：使用 实际执行时间 * nice_0_weight / weight，进程的nice值越高，weight越低，vruntime越大，
	被调度的可能越小)
	
82、RCU常用接口有？
	(tips： rcu_read_lock 读者加读锁，rcu_read_unlock 读者解锁
	rcu_dereference 读者拿到被保护的指针， rcu_assign_pointer 写者替换原来的指针
	rcu_sync 将替换行为同步给其他访问者)
	
83、传统RCU有什么问题？
	(tips：在大型系统中，随着核数的增多，在优雅周期的判断时，对于CPU mask 的争用加剧，导致RCU操作效率降低)
	
84、Tree RCU 又是怎么解决这个问题的？
	(tips：将CPU mask组织成树形结构，将CPU划分成组，不同的组访问不同的rcu_node，减少锁争用)
	
85、TASK_KILLABLE 状态的作用是？
	(tips：TASK_INTERUPTABLE 状态的进程可以响应信号，TASK_UNINTERRUPTABLE状态的进程又完全不响应信号，
	而TASK_KILLABLE是在这两者之间，首先，处于TASK_KILLABLE状态的进程也是可以响应信号的，
	当收到致命信号时，会唤醒对应进程。
	ps 命令输出中 D 状态的进程不一定就是 TASK_UNINTERRUPTABLE 的，也有可能是 TASK_KILLABLE 的，
	这个新的状态在 内核版本 2.6.26 之后添加)

86、flock和lockf调用的区别是？
	(tips：lockf是fcntl锁定操作的封装，是POSIX文件锁的实现，而flock则用了一个新的系统调用，
	lockf可以针对文件的range进行加锁，而flock不行，但是两者都是实现了基本的意向锁，但是，
	fcntl也有强制锁的实现)
	
87、schedule函数中选择下一个调度进程的方法是？
	(tips：Linux内核实现了四个调度类，stop停止类，rt实时类，fair公平类，idle空闲类，
	优先级从高到低，先在stop类中选择进程，如果没有则在rt类，接下来是fair类，再接下来是idle类，
	同时，实时类也对应之前O1调度算法中0~99 这个优先级区间的任务，fair对应的是100~139区间的优先级)

88、stop停止类只有一个任务，用于多CPU之间负载均衡相关或CPU热插拔，
	idle类也只有一个任务，用于CPU睡眠
	
89、新创建的进程的vruntime取值刚开始和父进程的vruntime一样，但要减去运行队列中的最小vruntime，
	之所以这样做，是因为要考虑多CPU之间的负载均衡，各个CPU上的运行队列的最小vruntime不一样，
	如果不这样做，直接迁移可能会造成负载不均衡。当确定好运行CPU后，再加上对应CPU运行队列的最小vruntime
	
90、唤醒后的进程的vruntime更新是在之前vruntime的基础上，用运行队列最小vruntime减去一个调度周期表示为vruntime1，
	然后取 max(当前进程vruntime，vruntime1)，这样就解决了长时间睡眠的进程醒来时由于vruntime太小而导致长期占用CPU
	
91、之前System V 风格的signal机制有一个问题，就是在信号处理函数不是默认值且设置了SA_ONESHOT标志后，
	内核会在自动在自定义信号处理函数执行后，恢复到默认信号处理函数。
	
92、信号值在 1~31 范围内的都是不可靠信号，即实现中是以位图来标志是否有挂起的信号，
	而又相同的信号时，会导致信号丢失。
	
93、信号中断系统调用表示？
	(tips：内核在执行慢速系统调用时有可能被信号打断而无法继续执行，这时接口会返回EINTR错误，
	为了可以让系统调用继续执行，可以在设置信号处理的行为为 SA_RESTART，但不是所有的系统调用都能自动继续执行，
	具体可以 man 7 signal 查看)
	
94、可靠信号的队列长度有限制吗？
	(tips：有，可以通过 ulimit -a 查看 signal pending 的取值)
	
95、信号与多线程的关系？
	(tips：
	1 信号处理函数在多线程之间共享，但是各个线程可以有自己的信号屏蔽集
	2 kill 函数必须面向进程
	3 每个发给多线程应用的信号，由内核随机挑一个未屏蔽该信号的线程来接收
	4 如果向多线程程序发送致命信号，那么内核将停止进程下的所有线程)
	
96、多个信号的投递优先级？
	(tips：优先处理私有信号队列，然后处理共享队列，
	优先处理SIGSEGV，SIGBUS，SIGILL，SIGTRAP，SIGFPE，SIGSYS同步信号，
	然后处理信号值小的信号，不可靠信号优先级高于可靠信号)
	
97、异步信号安全也要值得考虑，具体做法就是化异步为同步
	可以采用sigwait方法，也可以将signalfd返回的fd加入epoll中来处理，
	还可以通过管道的方式来处理，还可以通过socketpair来通知主进程有信号发生
	
98、匿名管道和命名管道的区别？
	(tips：匿名管道通过pipe函数创建，命名管道通过mkfifo函数创建)
	
99、管道空间有大小限制吗？
	(tips：有，如果写入的内容超过了管道空间，会报错)
	
100、多个进程向管道中写入数据时，是否是原子的？
	(tips：标准规定，写入PIPE_BUF大小的数据时，是原子的，这个值在linux上取值为 4096)
	
101、mmap的私有映射的实现？
	(tips：通过写时复制来实现，对于文件内容的修改，不会同步到底层文件中)
	
102、khungtaskd 功能？
	(tips：打印出长时间处于D状态的进程堆栈和对应告警信息，如果开启了hung_task_panic，那么内核会panic)
	
103、drop cache 操作导致机器磁盘util升高，可能的原因有？
	(tips：drop cache操作对应的是文件修改内容的写回，
	这时缓存在page cache中的数据将会排队写回磁盘，如果涉及的文件多，
	且位置随机，那么将会产生很多排队I/O，使磁盘util升高)
	
104、free命令显示可用内存小，程序crash原因及解决方案？




// 其他

1、内核和用户空间通信都有哪些方法？

2、服务器1U 2U 中的 U 表示什么？
   （tips：U是高度单位，大约 4.45 cm）

3、CDP技术介绍？
   （tips：持续数据持久化，通过内核层的hook来保证数据的安全性）

4、InfiniBand的带宽能达到多少？ Optic Fabric带宽能达到多少？
	(tips：200G，400G)
	
5、什么是 公网下沉？
	(在一台机器上同时部署两张网卡，一张网卡配置公网IP，另一张配置内网ip)
	
6、 SLC MLC TLC QLC 分表表示什么规格的SSD？

7、内核代码可以使用 -O0 编译吗？为什么？
	(tips：代码中内置了一些需要编译优化的代码片段，在-O0级别下编译会报错)
	
8、__attribute__((noinline)) 标识有什么作用？

9、什么是 DAS NAS SAN？

10、IP SAN 的概念？
	(tips：运行iSCSI协议的存储)
	
11、衡量文件系统性能的工具有哪些？
	(tips：FFSB，PostMark，IOZone，fio工具)


// shell
1、怎么样使alias永久生效？

2、source 命令有什么作用？

3、top 命令中CPU使用率高于100，是什么原因？
	(tips：机器有多个core，显示的是各个CPU利用率之和)
	
4、怎样确定一个shell 命令是builtin的？
	(tips：使用type命令查看)
	
5、怎样让系统生成core 文件？
	(tips：ulimit -c unlimited)
	
6、怎样定制core文件命名规则？
	(tips：/proc/sys/kernel/core_pattern)
